{
    "collab_server" : "",
    "contents" : "## This file is based on the ImageJ RoiDecoder class at:\n## http://imagej.nih.gov/ij/developer/source/ij/io/RoiDecoder.java.html\n## For information on how the ROIs are drawn, consult ROI methods in:\n## http://imagej.nih.gov/ij/developer/source/\n## \n##  ImageJ/NIH Image 64 byte ROI outline header\n##     2 byte numbers are big-endian signed shorts\n##     0-3     \"Iout\"\n##     4-5     version (>=217)\n##     6-7     roi type\n##     8-9     top\n##     10-11   left\n##     12-13   bottom\n##     14-15   right\n##     16-17   NCoordinates\n##     18-33   x1,y1,x2,y2 (straight line)\n##     34-35   stroke width (v1.43i or later)\n##     36-39   ShapeRoi size (type must be 1 if this value>0)\n##     40-43   stroke color (v1.43i or later)\n##     44-47   fill color (v1.43i or later)\n##     48-49   subtype (v1.43k or later)\n##     50-51   options (v1.43k or later)\n##     52-52   arrow style or aspect ratio (v1.43p or later)\n##     53-53   arrow head size (v1.43p or later)\n##     54-55   rounded rect arc size (v1.43p or later)\n##     56-59   position\n##     60-63   reserved (zeros)\n##     64-       x-coordinates (short), followed by y-coordinates\n##\n##' Read an ImageJ ROI file. This returns a structure containing the\n##' ImageJ data. \n##'\n##' @title Read an ImageJ ROI file\n##' @param file Name of ImageJ ROI file to read\n##' @param verbose Whether to report information\n##' @return A structure of class \\code{ijroi} containing the ROI information\n##' @author David Sterratt\n##' @export\n##' @seealso \\code{\\link{plot.ijroi}} for plotting single ROI objects.\n##' \n##' \\code{\\link{read.ijzip}} for reading several ROI objects from .zip files.\n##' @examples\n##' library(png)\n##' path <- file.path(system.file(package = \"RImageJROI\"), \"extdata\", \"ijroi\")\n##' im <- as.raster(readPNG(file.path(path, \"imagej-logo.png\")))\n##' plot(NA, NA, xlim=c(0, ncol(im)), ylim=c(nrow(im), 0), asp=1) \n##' rasterImage(im, 0,  nrow(im), ncol(im), 0, interpolate=FALSE)\n##' r <- read.ijroi(file.path(path, \"rect.roi\"))\n##' plot(r, TRUE)\n##' r <- read.ijroi(file.path(path, \"polygon.roi\"))\n##' plot(r, TRUE)\n##' r <- read.ijroi(file.path(path, \"oval.roi\"))\n##' plot(r, TRUE)\n##' \nread.ijroi <- function(file, verbose=FALSE) {\n  ## Define internal helper functions\n  getByte <- function(con) {\n    pos <- seek(con) \n    n <- readBin(con, raw(0), 1, size=1)\n    if (verbose)\n      message(paste(\"Pos \", pos , \": Byte \", n, sep=\"\"))\n    return(as.integer(n))\n  }\n  \n  getShort <- function(con) {\n    pos <- seek(con) \n    n <- readBin(con, integer(0), 1, size=2, signed=TRUE, endian=\"big\")\n    if (n < -5000) {\n      seek(con, -2, origin=\"current\")\n      n <- readBin(con, integer(0), 1, size=2, signed=FALSE, endian=\"big\")\n    }\n    if (verbose)\n      message(paste(\"Pos \", pos , \": Short \", n, sep=\"\"))\n    return(n)\n  }\n  \n  getInt <- function(con)  {\n    pos <- seek(con) \n    n <- readBin(con, integer(0), 1, size=4, signed=TRUE, endian=\"little\")\n    if (verbose)\n      message(paste(\"Pos \", pos , \": Integer \", n, sep=\"\"))\n    return (n);\n  }\n  \n  getFloat <- function(con)  {\n    pos <- seek(con) \n    n <- readBin(con, double(0), 1, size=4, signed=TRUE, endian=\"big\")\n    if (verbose)\n      message(paste(\"Pos \", pos , \": Float \", n, sep=\"\"))\n    return (n);\n  }\n  \n  ## subtypes\n  subtypes <- list(TEXT    = 1,\n                   ARROW   = 2,\n                   ELLIPSE = 3,\n                   IMAGE   = 4)\n  \n  ## options\n  opts <- list(SPLINE_FIT    = 1,\n               DOUBLE_HEADED = 2,\n               OUTLINE       = 4)\n  \n  ## types\n  types <- list(polygon  = 0,\n                rect     = 1,\n                oval     = 2,\n                line     = 3,\n                freeline = 4,\n                polyline = 5,\n                noRoi    = 6,\n                freehand = 7,\n                traced   = 8,\n                angle    = 9,\n                point    = 10)\n  \n  ## Main code\n  name <- NULL\n  if (!is.null(file)) {\n    size <- file.info(file)$size\n    if (!grepl(\".roi$\", file) && size>5242880)\n      stop(\"This is not an ROI or file size>5MB)\")\n    name <- basename(file)\n  }\n  \n  ## Open the connection\n  con <- file(file, \"rb\")\n  \n  ## Test that it's the right kind of file\n  if (getByte(con) != 73 || getByte(con) != 111) {  ## \"Iout\"\n    stop(\"This is not an ImageJ ROI\");\n  }\n  \n  if (verbose)\n    message(\"Reading format data\")\n  \n  ## Create place to store data\n  r <- list()\n  \n  ## Get the data. This all has to be in the order corresponding to\n  ## the positions mentioned at the top of the file. Uppercase text\n  ## corresponds to the static variables used in the ImageJ java file.\n  getShort(con)                    # 0-3 \"Iout\" Unused\n  r$version <-      getShort(con)  # 4-5 version (>=217)\n  r$type <-         getByte(con)   # 6-7 roi type\n  getByte(con)                     # Unused\n  r$top <-          getShort(con)  # 8-9   top TOP\n  r$left <-         getShort(con)  # 10-11 left LEFT\n  r$bottom <-       getShort(con)  # 12-13 bottom Bottom\n  r$right <-        getShort(con)  # 14-15 right  RIGHT\n  r$width <-    with(r, right-left)\n  r$height <-   with(r, bottom-top)\n  r$n <-            getShort(con)  # 16-17 NCoordinates N_COORDINATES\n  r$x1 <-           getFloat(con)  # 18-33 x1,y1,x2,y2 (straight line)\n  r$y1 <-           getFloat(con) \n  r$x2 <-           getFloat(con) \n  r$y2 <-           getFloat(con)\n  r$strokeWidth <-  getShort(con)  # 34-35 stroke width (v1.43i or later) STROKE_WIDTH\n  r$shapeRoiSize <- getInt(con)    # 36-39 ShapeRoi size (type must be 1 if this value>0) SHAPE_ROI_SIZE\n  r$strokeColor <-  getInt(con)    # 40-43 stroke color (v1.43i or later)\n  r$fillColor <-    getInt(con)    # 44-47 fill color (v1.43i or later) FILL_COLOR \n  r$subtype <-      getShort(con)  # 48-49 subtype (v1.43k or later)    SUBTYPE\n  r$options <-      getShort(con)  # 50-51 options (v1.43k or later)    OPTIONS\n  ## 52-55   style information or aspect ratio (v1.43p or later)\n  if ((r$type == types[\"freehand\"]) && (r$subtype == subtypes[\"ELLIPSE\"])) {\n    r$aspectRatio <- getFloat(con) # ELLIPSE_ASPECT_RATIO\n  } else {\n    r$style <-      getByte(con)   # 52-52 arrow style  (v1.43p or later)\n    r$headSize <-   getByte(con)   # 53-53 arrow head size (v1.43p or later) ARROW_HEAD_SIZE    \n    r$arcSize <-    getShort(con)  # 54-55 rounded rect arc size (v1.43p or later) ROUNDED_RECT_ARC_SIZE\n  }\n  r$position <-     getInt(con)    # 56-59 position POSITION\n  getShort(con)                    # 60-63   reserved (zeros) Unused\n  getShort(con)                    # Unused\n  \n  ## 64-       x-coordinates (short), followed by y-coordinates\n  if (verbose)\n    message(\"Reading coordinate data\")\n  \n  if (!is.null(name) && (grepl(\".roi$\", name)))\n    r$name <- substring(name, 1, nchar(name) - 4)\n  \n  isComposite <- (r$shapeRoiSize >0);\n  if (isComposite) {\n    stop(\"Composite ROIs not supported\")\n    ## roi = getShapeRoi();\n    ## if (version>=218) getStrokeWidthAndColor(roi);\n    ##          roi.setPosition(position);\n    ## return roi;\n  }\n  \n  if (r$type %in% types[\"line\"]) {\n    if (r$subtype %in% subtypes[\"ARROW\"]) {\n      r$doubleHeaded <- (r$options & opts$DOUBLE_HEADED)\n      r$outline <- (r$options & opts$OUTLINE)\n      ##                     if (style>=Arrow.FILLED && style<=Arrow.OPEN)\n      ##                         ((Arrow)roi).setStyle(style);\n      \n      ##                     if (headSize>=0 && style<=30)\n      ##                         ((Arrow)roi).setHeadSize(headSize);\n      ##                 } else\n      ##                     roi = new Line(x1, y1, x2, y2);\n    }\n  }\n  \n  ## Read in coordinates\n  if (r$type %in% types[c(\"polygon\", \"freehand\", \"traced\", \"polyline\", \"freeline\", \"angle\", \"point\")]) {\n    r$coords <- matrix(NA, r$n, 2)\n    if (r$n > 0) {\n      for (i in 1:r$n) {\n        r$coords[i, 1] <- getShort(con)\n      }\n      for (i in 1:r$n) {\n        r$coords[i, 2] <- getShort(con)\n      }\n      r$coords[r$coords<0] <- 0\n      r$coords[,1] <- r$coords[,1] + r$left\n      r$coords[,2] <- r$coords[,2] + r$top\n    }\n  }\n  close(con)\n  \n  ## Generate coordinates for r$type == line\n  if (r$type %in% types[\"line\"]){\n    r$coords <- matrix(NA, 2, 2)\n    r$coords[1,1] <- r$x1\n    r$coords[2,1] <- r$x2\n    r$coords[1,2] <- r$y1\n    r$coords[2,2] <- r$y2\n  }\n  \n  ## Fallback for if there are no co-ordinates\n  if (is.null(r$coords)) {\n    Xcoords <- unlist(c(r[names(r) %in% c(\"left\", \"x1\")],\n                        r[names(r) %in% c(\"right\", \"x2\")]))\n    Ycoords <- unlist(c(r[names(r) %in% c(\"top\", \"y1\")],\n                        r[names(r) %in% c(\"bottom\", \"y2\")]))\n    r$coords <- data.frame(x = Xcoords, y = Ycoords)\n  }\n  \n  ## Name columns of coordinates\n  colnames(r$coords) <- c(\"x\", \"y\")\n  \n  \n  ## Add type information\n  r$types <- types  \n  r$strType <- names(types)[which(types == r$type)]\n  \n  ## Add subtype information\n  if (r$subtype != 0) {\n    r$subtypes <- subtypes\n    r$strSubtype <- names(subtypes)[which(subtypes == r$subtype)]\n  }\n  \n  ## Add range to ease plotting\n  if(r$type == r$types[[\"oval\"]] | r$type == r$types[[\"rect\"]]) {\n    r$xrange <- range(c(r$left, r$right))\n  } else {\n    r$xrange <- range(r$coords[,1])\n  }\n  if(r$type == r$types[[\"oval\"]] | r$type == r$types[[\"rect\"]]) {\n    r$yrange <- range(c(r$top, r$bottom))\n  } else {\n    r$yrange <- range(r$coords[,2])\n  }\n  \n  \n  class(r) <- \"ijroi\"\n  return(r)\n}\n\n## Below is some unimplemented functionality from\n## http://imagej.nih.gov/ij/developer/source/ij/io/RoiDecoder.java.html\n## \n## ##         // read stroke width, stroke color and fill color (1.43i or later)\n## ##         if (version>=218) {\n## ##             getStrokeWidthAndColor(roi);\n## ##             boolean splineFit = (options&SPLINE_FIT)!=0;\n## ##             if (splineFit && roi instanceof PolygonRoi)\n## ##                 ((PolygonRoi)roi).fitSpline();\n## ##         }\n\n## ##         if (version>=218 && subtype==TEXT)\n## ##             roi = getTextRoi(roi);\n\n## ##         roi.setPosition(position);\n## ##         return roi;\n## ##     }\n\n## ## }\n\n## ##     void getStrokeWidthAndColor(Roi roi) {\n## ##         if (strokeWidth>0)\n## ##             roi.setStrokeWidth(strokeWidth);\n## ##         if (strokeColor!=0) {\n## ##             int alpha = (strokeColor>>24)&0xff;\n## ##             roi.setStrokeColor(new Color(strokeColor, alpha!=255));\n## ##         }\n\n## ##         if (fillColor!=0) {\n## ##             int alpha = (fillColor>>24)&0xff;\n## ##             roi.setFillColor(new Color(fillColor, alpha!=255));\n## ##         }\n## ##     }\n\n## ##     Roi getTextRoi(Roi roi) {\n## ##         Rectangle r = roi.getBounds();\n## ##         int hdrSize = RoiEncoder.HEADER_SIZE;\n## ##         int size = getInt(hdrSize);\n## ##         int style = getInt(hdrSize+4);\n## ##         int nameLength = getInt(hdrSize+8);\n## ##         int textLength = getInt(hdrSize+12);\n## ##         char[] name = new char[nameLength];\n## ##         char[] text = new char[textLength];\n## ##         for (int i=0; i<nameLength; i++)\n## ##             name[i] = (char)getShort(hdrSize+16+i*2);\n## ##         for (int i=0; i<textLength; i++)\n## ##             text[i] = (char)getShort(hdrSize+16+nameLength*2+i*2);\n## ##         Font font = new Font(new String(name), style, size);\n## ##         Roi roi2 = new TextRoi(r.x, r.y, new String(text), font);\n## ##         roi2.setStrokeColor(roi.getStrokeColor());\n## ##         roi2.setFillColor(roi.getFillColor());\n## ##         return roi2;\n## ##     }",
    "created" : 1516917402461.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3476938478",
    "id" : "C68E4ED",
    "lastKnownWriteTime" : 1516229035,
    "last_content_update" : 1516229035,
    "path" : "~/Documents/GitHub/leeplyr/R/readROIImageJ.R",
    "project_path" : "R/readROIImageJ.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}